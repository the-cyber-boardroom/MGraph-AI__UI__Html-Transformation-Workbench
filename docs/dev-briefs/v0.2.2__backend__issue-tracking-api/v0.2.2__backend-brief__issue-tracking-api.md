# Backend Brief: Issue Tracking API

## Overview

This brief describes the FastAPI backend implementation required to enable full CRUD operations for the issue tracking system. The frontend (v0.1.6) currently works with a read-only file-based system. This backend will add write capabilities while maintaining backward compatibility with the existing JSON file structure.

---

## Current State

### Existing File Structure

The frontend reads from JSON files located in `docs/dev-briefs/issues/`:

```
docs/dev-briefs/issues/
├── issues.json          # Index of all issues
├── labels.json          # Label definitions
├── issue-001.json       # Individual issue files
├── issue-002.json
├── ...
└── issue-010.json
```

### Current Frontend Behavior

The UI fetches these files via HTTP GET requests:
- `GET /dev-briefs/issues/issues.json` - Get issue index
- `GET /dev-briefs/issues/labels.json` - Get labels
- `GET /dev-briefs/issues/issue-{id}.json` - Get individual issue

The FastAPI server currently serves these as static files from the `docs/` directory.

---

## Required API Endpoints

### Issue CRUD Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/api/issues` | List all issues (returns issues.json data) |
| `GET` | `/api/issues/{id}` | Get single issue details |
| `POST` | `/api/issues` | Create new issue |
| `PATCH` | `/api/issues/{id}` | Update issue (partial update) |
| `DELETE` | `/api/issues/{id}` | Delete issue |
| `POST` | `/api/issues/{id}/comments` | Add comment to issue |
| `PATCH` | `/api/issues/{id}/status` | Update issue status (shorthand) |

### Label Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/api/labels` | List all labels |
| `POST` | `/api/labels` | Create new label |
| `DELETE` | `/api/labels/{name}` | Delete label |

---

## Data Schemas

### Issue Schema

```python
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from enum import Enum

class IssueStatus(str, Enum):
    BACKLOG = "backlog"
    TODO = "todo"
    IN_PROGRESS = "in-progress"
    REVIEW = "review"
    DONE = "done"

class ChecklistItem(BaseModel):
    item: str
    done: bool = False

class Comment(BaseModel):
    author: str  # "human" or "claude-code"
    timestamp: datetime
    text: str

class Issue(BaseModel):
    id: str
    title: str
    description: Optional[str] = ""
    status: IssueStatus = IssueStatus.BACKLOG
    labels: List[str] = []
    created: datetime
    updated: datetime
    targetVersion: Optional[str] = None
    comments: List[Comment] = []
    checklist: List[ChecklistItem] = []

class IssueSummary(BaseModel):
    id: str
    title: str
    status: IssueStatus

class IssuesIndex(BaseModel):
    lastUpdated: datetime
    nextId: int
    issues: List[IssueSummary]
    statusCounts: dict
```

### Create/Update DTOs

```python
class CreateIssueRequest(BaseModel):
    title: str
    description: Optional[str] = ""
    status: IssueStatus = IssueStatus.BACKLOG
    labels: List[str] = []
    targetVersion: Optional[str] = None
    checklist: List[ChecklistItem] = []

class UpdateIssueRequest(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    status: Optional[IssueStatus] = None
    labels: Optional[List[str]] = None
    targetVersion: Optional[str] = None
    checklist: Optional[List[ChecklistItem]] = None

class AddCommentRequest(BaseModel):
    author: str = "human"
    text: str

class Label(BaseModel):
    name: str
    color: str  # Hex color like "#22c55e"
    description: Optional[str] = ""
```

---

## Implementation Details

### File-Based Persistence

The backend should continue using the file system as the data store. This keeps the system simple and allows direct inspection/editing of JSON files.

```python
import json
from pathlib import Path
from datetime import datetime

ISSUES_DIR = Path("docs/dev-briefs/issues")

class IssueRepository:
    def __init__(self, base_path: Path = ISSUES_DIR):
        self.base_path = base_path
        self.base_path.mkdir(parents=True, exist_ok=True)

    def get_index(self) -> dict:
        index_path = self.base_path / "issues.json"
        if index_path.exists():
            return json.loads(index_path.read_text())
        return {"lastUpdated": None, "nextId": 1, "issues": [], "statusCounts": {}}

    def save_index(self, index: dict):
        index["lastUpdated"] = datetime.utcnow().isoformat() + "Z"
        index_path = self.base_path / "issues.json"
        index_path.write_text(json.dumps(index, indent=2))

    def get_issue(self, issue_id: str) -> dict:
        issue_path = self.base_path / f"{issue_id}.json"
        if not issue_path.exists():
            raise FileNotFoundError(f"Issue {issue_id} not found")
        return json.loads(issue_path.read_text())

    def save_issue(self, issue: dict):
        issue["updated"] = datetime.utcnow().isoformat() + "Z"
        issue_path = self.base_path / f"{issue['id']}.json"
        issue_path.write_text(json.dumps(issue, indent=2))

    def delete_issue(self, issue_id: str):
        issue_path = self.base_path / f"{issue_id}.json"
        if issue_path.exists():
            issue_path.unlink()

    def get_labels(self) -> dict:
        labels_path = self.base_path / "labels.json"
        if labels_path.exists():
            return json.loads(labels_path.read_text())
        return {"labels": []}

    def save_labels(self, labels: dict):
        labels_path = self.base_path / "labels.json"
        labels_path.write_text(json.dumps(labels, indent=2))
```

### API Router Implementation

```python
from fastapi import APIRouter, HTTPException
from datetime import datetime

router = APIRouter(prefix="/api", tags=["issues"])
repo = IssueRepository()

@router.get("/issues")
def list_issues():
    """Get all issues (index)"""
    return repo.get_index()

@router.get("/issues/{issue_id}")
def get_issue(issue_id: str):
    """Get single issue by ID"""
    try:
        return repo.get_issue(issue_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Issue {issue_id} not found")

@router.post("/issues", status_code=201)
def create_issue(request: CreateIssueRequest):
    """Create new issue"""
    index = repo.get_index()

    # Generate new ID
    next_id = index.get("nextId", 1)
    issue_id = f"issue-{next_id:03d}"

    # Create issue
    now = datetime.utcnow().isoformat() + "Z"
    issue = {
        "id": issue_id,
        "title": request.title,
        "description": request.description,
        "status": request.status,
        "labels": request.labels,
        "created": now,
        "updated": now,
        "targetVersion": request.targetVersion,
        "comments": [],
        "checklist": [item.dict() for item in request.checklist]
    }

    # Save issue file
    repo.save_issue(issue)

    # Update index
    index["nextId"] = next_id + 1
    index["issues"].append({
        "id": issue_id,
        "title": request.title,
        "status": request.status
    })
    _update_status_counts(index)
    repo.save_index(index)

    return issue

@router.patch("/issues/{issue_id}")
def update_issue(issue_id: str, request: UpdateIssueRequest):
    """Update issue (partial update)"""
    try:
        issue = repo.get_issue(issue_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Issue {issue_id} not found")

    # Apply updates
    update_data = request.dict(exclude_unset=True)
    for key, value in update_data.items():
        if key == "checklist" and value is not None:
            issue[key] = [item.dict() if hasattr(item, 'dict') else item for item in value]
        elif value is not None:
            issue[key] = value

    repo.save_issue(issue)

    # Update index if title or status changed
    if "title" in update_data or "status" in update_data:
        index = repo.get_index()
        for idx, summary in enumerate(index["issues"]):
            if summary["id"] == issue_id:
                if "title" in update_data:
                    index["issues"][idx]["title"] = update_data["title"]
                if "status" in update_data:
                    index["issues"][idx]["status"] = update_data["status"]
                break
        _update_status_counts(index)
        repo.save_index(index)

    return issue

@router.delete("/issues/{issue_id}", status_code=204)
def delete_issue(issue_id: str):
    """Delete issue"""
    try:
        repo.get_issue(issue_id)  # Verify exists
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Issue {issue_id} not found")

    repo.delete_issue(issue_id)

    # Update index
    index = repo.get_index()
    index["issues"] = [i for i in index["issues"] if i["id"] != issue_id]
    _update_status_counts(index)
    repo.save_index(index)

@router.post("/issues/{issue_id}/comments", status_code=201)
def add_comment(issue_id: str, request: AddCommentRequest):
    """Add comment to issue"""
    try:
        issue = repo.get_issue(issue_id)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Issue {issue_id} not found")

    comment = {
        "author": request.author,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "text": request.text
    }

    issue["comments"].append(comment)
    repo.save_issue(issue)

    return comment

@router.patch("/issues/{issue_id}/status")
def update_status(issue_id: str, status: IssueStatus):
    """Quick status update"""
    return update_issue(issue_id, UpdateIssueRequest(status=status))

def _update_status_counts(index: dict):
    """Recalculate status counts"""
    counts = {"backlog": 0, "todo": 0, "in-progress": 0, "review": 0, "done": 0}
    for issue in index["issues"]:
        status = issue.get("status", "backlog")
        if status in counts:
            counts[status] += 1
    index["statusCounts"] = counts
```

---

## Frontend Integration

### Updated Issue Service

The frontend `issue-service.js` (v0.1.6) will need updates to use the new API endpoints for write operations:

```javascript
// Add to IssueService class

async createIssue(issueData) {
    const response = await fetch('/api/issues', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(issueData)
    });
    if (!response.ok) throw new Error('Failed to create issue');
    const issue = await response.json();
    this._emit('issue-created', { issue });
    await this.refresh();
    return issue;
}

async updateIssue(issueId, updates) {
    const response = await fetch(`/api/issues/${issueId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(updates)
    });
    if (!response.ok) throw new Error('Failed to update issue');
    const issue = await response.json();
    this._issueCache.set(issueId, issue);
    this._emit('issue-updated', { issue });
    return issue;
}

async deleteIssue(issueId) {
    const response = await fetch(`/api/issues/${issueId}`, {
        method: 'DELETE',
        credentials: 'include'
    });
    if (!response.ok) throw new Error('Failed to delete issue');
    this._issueCache.delete(issueId);
    this._emit('issue-deleted', { id: issueId });
    await this.refresh();
}

async addComment(issueId, text, author = 'human') {
    const response = await fetch(`/api/issues/${issueId}/comments`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ author, text })
    });
    if (!response.ok) throw new Error('Failed to add comment');
    const comment = await response.json();

    // Update cached issue
    const issue = this._issueCache.get(issueId);
    if (issue) {
        issue.comments.push(comment);
    }

    this._emit('comment-added', { issueId, comment });
    return comment;
}

async updateStatus(issueId, status) {
    return this.updateIssue(issueId, { status });
}
```

---

## Validation Rules

### Issue Validation
- `title`: Required, 1-200 characters
- `description`: Optional, max 10000 characters
- `status`: Must be one of: backlog, todo, in-progress, review, done
- `labels`: Array of strings, each must exist in labels.json
- `targetVersion`: Optional, format like "v0.1.6"

### Comment Validation
- `author`: Required, either "human" or "claude-code"
- `text`: Required, 1-5000 characters

### Label Validation
- `name`: Required, 1-50 characters, alphanumeric with hyphens
- `color`: Required, valid hex color (#RRGGBB)
- `description`: Optional, max 200 characters

---

## Error Handling

Return appropriate HTTP status codes:

| Code | Use Case |
|------|----------|
| 200 | Successful GET, PATCH |
| 201 | Successful POST (created) |
| 204 | Successful DELETE (no content) |
| 400 | Invalid request body |
| 404 | Issue/label not found |
| 422 | Validation error |
| 500 | Server error |

Error response format:
```json
{
    "detail": "Error message here",
    "errors": [
        {"field": "title", "message": "Title is required"}
    ]
}
```

---

## Testing Checklist

### Unit Tests
- [ ] Create issue with valid data
- [ ] Create issue with missing required fields
- [ ] Update issue status
- [ ] Update issue with invalid status
- [ ] Delete existing issue
- [ ] Delete non-existent issue
- [ ] Add comment to issue
- [ ] List all issues
- [ ] Get single issue
- [ ] Label CRUD operations

### Integration Tests
- [ ] Full issue lifecycle (create → update → comment → complete → delete)
- [ ] Concurrent updates
- [ ] Index consistency after operations
- [ ] File persistence verification

---

## Deployment Notes

### CORS Configuration
Ensure the FastAPI app allows requests from the frontend:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Or specific origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### Mount Static Files
The existing static file serving for `docs/dev-briefs/` should continue to work for backward compatibility. The new API routes take precedence.

### File Permissions
Ensure the FastAPI process has write permissions to `docs/dev-briefs/issues/`.

---

## Future Considerations

### Phase 3 Features (Not in Scope)
- Issue search with full-text indexing
- Issue attachments
- Issue linking (related issues, blocks/blocked by)
- Activity log / audit trail
- User authentication and ownership
- Notifications / webhooks

### Performance Optimization
For larger issue counts (100+), consider:
- Caching the index in memory
- Lazy loading of individual issues
- Pagination for list endpoints

---

## Summary

This backend implementation adds write capabilities to the existing file-based issue tracking system. Key points:

1. **File-based persistence** - Continues using JSON files for simplicity
2. **RESTful API** - Standard CRUD endpoints under `/api/`
3. **Backward compatible** - Existing static file serving still works
4. **Pydantic validation** - Strong typing and validation
5. **Index maintenance** - Automatic status count updates

The frontend (v0.1.6) can start using these endpoints once available, with minimal changes to the existing `issue-service.js`.
