# Backend Brief: Graph-Based Issue Tracking System v2

**Version:** 0.2.4 
**Status:** Architecture Design  
**Supersedes:** v0.2.2 (Simple Issue CRUD)

---

## Executive Summary

This document describes the evolution of our issue tracking system from a flat file-based structure to a **graph-based node and edge system** stored in Git. The new architecture treats every entity (issues, people, roles) as nodes with unique identifiers, connected by typed relationships (edges). This enables powerful visualisation, querying, and AI agent coordination while maintaining Git as the source of truth.

---

## Part 1: Why We Are Doing This

### The Problem with Flat Issue Lists

Traditional issue tracking treats tickets as isolated records in a list. This creates several limitations:

1. **No Semantic Context** — "Issue-756" tells you nothing. Is it critical? Is it a bug or a feature? Who owns it?

2. **Weak Relationships** — Issues exist in isolation. You cannot easily answer: "What tasks belong to this feature?" or "What bugs block this release?"

3. **Poor Agent Coordination** — When AI agents work on tasks, they need structured context about dependencies, ownership, and workflow state. Flat lists don't provide this.

4. **Limited Visualisation** — You cannot generate meaningful graphs or dependency maps from unstructured data.

### The Opportunity

By treating issues as **nodes in a graph**, we unlock:

- **Rich Identity** — Every node has a unique GUID for machine processing AND a human-readable label (`Bug-27`, `Feature-3`) for discoverability
- **Typed Entities** — Different node types (bugs, tasks, features, people) with their own schemas and behaviours
- **Explicit Relationships** — Bidirectional edges with semantic meaning ("blocks/blocked-by", "has-task/task-of")
- **Git as Database** — Full version history, branch-based workflows, and the ability to edit data directly in repository browsers
- **Agent-Native Design** — Structured data that AI agents can parse, reason about, and manipulate

---

## Part 2: What We Are Building

### Core Concepts

| Concept | Description | Example |
|---------|-------------|---------|
| **Node** | Any entity in the system | Bug, Task, Feature, Person, Role |
| **Node ID** | 10-character alphanumeric GUID | `a1b2c3d4e5` |
| **Label** | Human-readable identifier | `Bug-27`, `Task-103`, `Person-alice` |
| **Node Type** | Classification with its own schema | `bug`, `task`, `feature`, `person` |
| **Edge** | Relationship between two nodes | Bug-27 → blocks → Task-15 |
| **Link Type** | Definition of relationship semantics | `{ verb: "blocks", inverse: "blocked-by" }` |

### Identity Model

Every node has THREE identity components:

```
┌─────────────────────────────────────────────────────────┐
│  Node Identity                                          │
├─────────────────────────────────────────────────────────┤
│  node_id      : "a1b2c3d4e5"     (GUID - machine use)   │
│  node_type    : "bug"            (classification)       │
│  node_index   : 27               (per-type counter)     │
│  label        : "Bug-27"         (human-readable)       │
└─────────────────────────────────────────────────────────┘
```

**Key Design Decisions:**

1. **`node_id`** is a random 10-char alphanumeric GUID (like our MGraph Object IDs)
2. **`node_index`** is sequential PER TYPE (Bug-1, Bug-2... Task-1, Task-2...)
3. **`label`** is derived: `{NodeType}-{node_index}` with capitalisation
4. **Files are named by label** for GitHub browsability: `Bug-27/node.json`

### Relationship Model

Relationships are **bidirectional** and **denormalised**:

```
┌──────────────┐         blocks          ┌──────────────┐
│   Bug-27     │ ───────────────────────▶│   Task-15    │
│              │◀─────────────────────── │              │
└──────────────┘      blocked-by         └──────────────┘
```

When a link is created:
- Bug-27's `links` array gets: `{ link_type_id, verb: "blocks", target_id: Task-15.node_id }`
- Task-15's `links` array gets: `{ link_type_id, verb: "blocked-by", target_id: Bug-27.node_id }`

This denormalisation means each node is self-contained — you can read a single file and know all its relationships.

---

## Part 3: How We Are Implementing This

### Directory Structure

```
.issues/
├── config/
│   ├── node-types.json          # Definitions of all node types
│   ├── link-types.json          # Definitions of all relationship types
│   └── settings.json            # Global settings (compression, etc.)
│
├── data/
│   ├── bug/
│   │   ├── Bug-1/
│   │   │   ├── node.json        # Node data
│   │   │   └── attachments/     # Screenshots, files
│   │   │       ├── screenshot-001.png
│   │   │       └── log-file.txt
│   │   ├── Bug-2/
│   │   │   ├── node.json
│   │   │   └── attachments/
│   │   └── _index.json          # Bug type index (next_index, count)
│   │
│   ├── task/
│   │   ├── Task-1/
│   │   │   └── node.json
│   │   ├── Task-2/
│   │   │   └── node.json
│   │   └── _index.json
│   │
│   ├── feature/
│   │   └── ...
│   │
│   ├── person/
│   │   ├── Person-alice/
│   │   │   └── node.json
│   │   └── _index.json
│   │
│   └── role/
│       ├── Role-developer/
│       │   └── node.json
│       └── _index.json
│
└── _index.json                  # Global index (total nodes, last updated)
```

### Why This Structure?

1. **Folder per Issue** — Each node gets a folder, not just a file. This allows attachments, comments, and future extensions without restructuring.

2. **Type-based Organisation** — Browsing `.issues/data/bug/` shows all bugs. Simple and intuitive.

3. **Named by Label** — `Bug-27/` is immediately meaningful when browsing the repository.

4. **Index Files** — `_index.json` per type tracks the next available index and provides quick counts without scanning all files.

5. **Config Separation** — Type and link definitions live in `config/`, separate from data.

---

## Part 4: Data Schemas

### 4.1 Node Schema (Base)

All nodes share this base structure:

```python
class Schema__Node(Type_Safe):
    node_id       : Safe_Id                              # Random 10-char GUID
    node_type_id  : Safe_Id                              # Reference to node type
    node_type     : Safe_Str                             # Denormalised type name
    node_index    : Safe_UInt                            # Per-type sequential number
    label         : Safe_Str                             # Human-readable: "Bug-27"
    
    title         : Safe_Str                             # Display title
    description   : Safe_Str                             # Detailed description
    status        : Safe_Str                             # Current status
    
    created_at    : Safe_Str                             # ISO timestamp
    updated_at    : Safe_Str                             # ISO timestamp
    created_by    : Safe_Id                              # Person/agent node_id
    
    labels        : List[Safe_Str]                       # Tags/categories
    links         : List[Schema__Node__Link]             # Relationships to other nodes
    
    properties    : Dict[Safe_Str, Any]                  # Type-specific properties
```

### 4.2 Node Link Schema

```python
class Schema__Node__Link(Type_Safe):
    link_type_id  : Safe_Id                              # Reference to link type
    verb          : Safe_Str                             # "blocks", "has-task", etc.
    target_id     : Safe_Id                              # Target node's node_id
    target_label  : Safe_Str                             # Denormalised: "Task-15"
    created_at    : Safe_Str                             # When link was created
```

### 4.3 Node Type Schema

```python
class Schema__Node__Type(Type_Safe):
    type_id       : Safe_Id                              # Unique identifier
    name          : Safe_Str                             # "bug", "task", "feature"
    display_name  : Safe_Str                             # "Bug", "Task", "Feature"
    description   : Safe_Str                             # What this type represents
    icon          : Safe_Str                             # Optional icon identifier
    color         : Safe_Str__Hex_Color                  # Display color
    
    statuses      : List[Safe_Str]                       # Valid statuses for this type
    default_status: Safe_Str                             # Initial status
    
    properties    : List[Schema__Property__Definition]   # Type-specific fields
```

### 4.4 Link Type Schema

```python
class Schema__Link__Type(Type_Safe):
    link_type_id  : Safe_Id                              # Unique identifier
    verb          : Safe_Str                             # "blocks", "has-task"
    inverse_verb  : Safe_Str                             # "blocked-by", "task-of"
    description   : Safe_Str                             # What this relationship means
    
    source_types  : List[Safe_Str]                       # Valid source node types
    target_types  : List[Safe_Str]                       # Valid target node types
```

### 4.5 Type Index Schema

```python
class Schema__Type__Index(Type_Safe):
    node_type     : Safe_Str                             # "bug", "task", etc.
    next_index    : Safe_UInt                            # Next available index
    count         : Safe_UInt                            # Total nodes of this type
    last_updated  : Safe_Str                             # ISO timestamp
```

### 4.6 Attachment Schema

```python
class Schema__Attachment(Type_Safe):
    attachment_id : Safe_Id                              # Unique identifier
    filename      : Safe_Str                             # Original filename
    stored_name   : Safe_Str                             # Name on disk (may differ)
    mime_type     : Safe_Str                             # "image/png", "text/plain"
    size_bytes    : Safe_UInt                            # File size
    compressed    : bool                                 # Whether compression applied
    created_at    : Safe_Str                             # Upload timestamp
    created_by    : Safe_Id                              # Uploader node_id
```

---

## Part 5: Predefined Types

### 5.1 Node Types (Initial Set)

| Type | Display Name | Description | Statuses |
|------|--------------|-------------|----------|
| `bug` | Bug | Defect or error | backlog, confirmed, in-progress, testing, resolved, closed |
| `task` | Task | Unit of work | backlog, todo, in-progress, review, done |
| `story` | Story | User-facing requirement | backlog, ready, in-progress, review, done |
| `feature` | Feature | High-level capability | proposed, approved, in-progress, released |
| `epic` | Epic | Large initiative | proposed, in-progress, done |
| `question` | Question | Clarification needed | open, answered, closed |
| `todo` | To-Do | Simple action item | pending, done |
| `risk` | Risk | Potential problem | identified, mitigating, mitigated, accepted |
| `vulnerability` | Vulnerability | Security issue | reported, confirmed, fixing, resolved, verified |
| `requirement` | Requirement | Specification | draft, approved, implemented, verified |
| `person` | Person | Human or agent identity | active, inactive |
| `role` | Role | Assigned responsibility | active, inactive |

### 5.2 Link Types (Initial Set)

| Verb | Inverse Verb | Description |
|------|--------------|-------------|
| `blocks` | `blocked-by` | Prevents progress on target |
| `depends-on` | `dependency-of` | Requires target to complete first |
| `has-task` | `task-of` | Contains as sub-work |
| `has-bug` | `bug-of` | Has associated defect |
| `has-requirement` | `requirement-of` | Has specification |
| `relates-to` | `relates-to` | General association (symmetric) |
| `duplicates` | `duplicated-by` | Same as another node |
| `assigned-to` | `assignee-of` | Work assignment |
| `created-by` | `creator-of` | Authorship |
| `owned-by` | `owner-of` | Responsibility |

---

## Part 6: API Endpoints

### 6.1 Node Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/api/nodes` | List all nodes (with filters) |
| `GET` | `/api/nodes/{label}` | Get node by label (e.g., Bug-27) |
| `GET` | `/api/nodes/id/{node_id}` | Get node by GUID |
| `POST` | `/api/nodes` | Create new node |
| `PATCH` | `/api/nodes/{label}` | Update node |
| `DELETE` | `/api/nodes/{label}` | Delete node |

### 6.2 Node Type Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/api/types` | List all node types |
| `GET` | `/api/types/{name}` | Get type definition |
| `POST` | `/api/types` | Create new type |
| `PATCH` | `/api/types/{name}` | Update type |
| `DELETE` | `/api/types/{name}` | Delete type (if no nodes) |
| `GET` | `/api/types/{name}/nodes` | List all nodes of type |

### 6.3 Link Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/api/nodes/{label}/links` | Add link to node |
| `DELETE` | `/api/nodes/{label}/links/{target_label}` | Remove link |
| `GET` | `/api/link-types` | List all link types |
| `POST` | `/api/link-types` | Create link type |

### 6.4 Attachment Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/api/nodes/{label}/attachments` | List attachments |
| `POST` | `/api/nodes/{label}/attachments` | Upload attachment |
| `GET` | `/api/nodes/{label}/attachments/{filename}` | Download attachment |
| `DELETE` | `/api/nodes/{label}/attachments/{filename}` | Delete attachment |

### 6.5 Graph Operations

| Method | Endpoint | Description |
|--------|----------|-------------|
| `GET` | `/api/graph` | Get full graph (nodes + edges) |
| `GET` | `/api/graph/subgraph/{label}` | Get connected subgraph from node |
| `GET` | `/api/graph/path/{from_label}/{to_label}` | Find paths between nodes |

---

## Part 7: Image Compression

### Requirements

1. **Auto-compress on upload** — All images processed automatically
2. **Preserve originals optionally** — Configuration flag to keep originals
3. **Target reasonable sizes** — Screenshots don't need 4K resolution
4. **Support common formats** — PNG, JPEG, WebP

### Compression Strategy

```python
class Attachment__Compression__Config(Type_Safe):
    enabled           : bool        = True
    max_dimension     : Safe_UInt   = Safe_UInt(1920)    # Max width or height
    jpeg_quality      : Safe_UInt   = Safe_UInt(85)      # JPEG quality (0-100)
    png_compression   : Safe_UInt   = Safe_UInt(6)       # PNG compression (0-9)
    convert_to_webp   : bool        = False              # Convert all to WebP
    preserve_original : bool        = False              # Keep uncompressed copy
```

### Compression Flow

```
Upload Image
     │
     ▼
┌─────────────────┐
│ Check Dimensions│
└────────┬────────┘
         │
         ▼
    Need Resize?  ──Yes──▶ Resize to max_dimension
         │                       │
         No                      │
         │◀──────────────────────┘
         ▼
┌─────────────────┐
│ Apply Format    │
│ Compression     │
└────────┬────────┘
         │
         ▼
    Save to attachments/
```

---

## Part 8: Agent Integration

### Design for AI Agents

This system is explicitly designed for AI agent coordination:

1. **Structured Data** — JSON schemas that agents can parse and validate
2. **Clear Ownership** — Person/Role nodes for agent identities
3. **Task Assignment** — `assigned-to` links connect work to agents
4. **Status Workflow** — Agents update status as they progress
5. **Dependency Tracking** — `blocks`/`depends-on` for work ordering

### Agent Workflow Example

```
1. Agent spawns → Creates/references Person node (Person-agent-001)
2. Agent assigned task → Task-15 gets link: assigned-to → Person-agent-001
3. Agent starts work → Task-15 status: in-progress
4. Agent finds bug → Creates Bug-42 with link: bug-of → Task-15
5. Agent completes → Task-15 status: done
6. Agent reports → Updates Task-15 description with summary
```

### Agent Identity Nodes

```python
# Example Person node for an agent
{
    "node_id": "a1b2c3d4e5",
    "node_type": "person",
    "label": "Person-code-agent-01",
    "title": "Code Review Agent",
    "description": "Automated agent for code review tasks",
    "properties": {
        "agent_type": "code-review",
        "model": "claude-sonnet-4",
        "capabilities": ["python", "javascript", "security-scan"]
    }
}
```

---

## Part 9: Migration Notes

### From v0.2.2

The v0.2.2 structure is being replaced entirely:

| v0.2.2 | v0.3.0 |
|--------|--------|
| `issues/issues.json` | `.issues/_index.json` |
| `issues/Issue-001.json` | `.issues/data/task/Task-1/node.json` |
| `issues/labels.json` | `.issues/config/node-types.json` (labels become type-specific) |

**No migration path** — The new structure is different enough that we start fresh. Existing data can be manually recreated if needed.

### Breaking Changes

1. Issue IDs change from `Issue-NNN` to type-specific labels
2. Directory structure completely different
3. All endpoints change paths
4. Schema fields renamed for consistency

---

## Part 10: Implementation Phases

### Phase 1: Core Infrastructure
- [ ] Directory structure creation
- [ ] Node type definitions and storage
- [ ] Link type definitions and storage
- [ ] Base node CRUD operations
- [ ] Type index management

### Phase 2: Relationships
- [ ] Link creation (bidirectional)
- [ ] Link deletion (bidirectional)
- [ ] Link validation (type constraints)
- [ ] Relationship queries

### Phase 3: Attachments
- [ ] File upload endpoint
- [ ] Image compression pipeline
- [ ] Attachment metadata tracking
- [ ] Attachment retrieval/deletion

### Phase 4: Graph Operations
- [ ] Full graph export
- [ ] Subgraph extraction
- [ ] Path finding
- [ ] Visualisation data format

### Phase 5: Agent Features
- [ ] Agent identity management
- [ ] Assignment workflows
- [ ] Status transition validation
- [ ] Activity logging

---

## Appendix A: Example Node Files

### Bug Node

**File:** `.issues/data/bug/Bug-27/node.json`

```json
{
    "node_id": "f7k2m9p4q1",
    "node_type_id": "a1b2c3d4e5",
    "node_type": "bug",
    "node_index": 27,
    "label": "Bug-27",
    
    "title": "Login fails with special characters in password",
    "description": "Users with passwords containing '&' or '<' cannot log in.",
    "status": "confirmed",
    
    "created_at": "2026-01-30T10:00:00Z",
    "updated_at": "2026-01-30T14:30:00Z",
    "created_by": "x9y8z7w6v5",
    
    "labels": ["security", "high-priority", "login"],
    
    "links": [
        {
            "link_type_id": "b2c3d4e5f6",
            "verb": "blocks",
            "target_id": "h3j4k5l6m7",
            "target_label": "Task-15",
            "created_at": "2026-01-30T11:00:00Z"
        },
        {
            "link_type_id": "c3d4e5f6g7",
            "verb": "bug-of",
            "target_id": "n8o9p0q1r2",
            "target_label": "Feature-3",
            "created_at": "2026-01-30T10:00:00Z"
        }
    ],
    
    "properties": {
        "severity": "high",
        "browser": "Chrome 120",
        "reproducible": true
    }
}
```

### Person Node (Agent)

**File:** `.issues/data/person/Person-security-scanner/node.json`

```json
{
    "node_id": "s4t5u6v7w8",
    "node_type_id": "d4e5f6g7h8",
    "node_type": "person",
    "node_index": 5,
    "label": "Person-security-scanner",
    
    "title": "Security Scanner Agent",
    "description": "Automated agent for vulnerability scanning",
    "status": "active",
    
    "created_at": "2026-01-15T08:00:00Z",
    "updated_at": "2026-01-30T06:00:00Z",
    "created_by": "admin-user-id",
    
    "labels": ["agent", "security", "automated"],
    
    "links": [
        {
            "link_type_id": "e5f6g7h8i9",
            "verb": "assignee-of",
            "target_id": "f7k2m9p4q1",
            "target_label": "Bug-27",
            "created_at": "2026-01-30T10:05:00Z"
        }
    ],
    
    "properties": {
        "agent_type": "security-scanner",
        "model": "claude-sonnet-4",
        "scan_schedule": "daily",
        "last_scan": "2026-01-30T06:00:00Z"
    }
}
```

---

## Appendix B: Configuration Files

### node-types.json

**File:** `.issues/config/node-types.json`

```json
{
    "types": [
        {
            "type_id": "a1b2c3d4e5",
            "name": "bug",
            "display_name": "Bug",
            "description": "Defect or error in the system",
            "icon": "bug",
            "color": "#ef4444",
            "statuses": ["backlog", "confirmed", "in-progress", "testing", "resolved", "closed"],
            "default_status": "backlog",
            "properties": [
                { "name": "severity", "type": "enum", "options": ["low", "medium", "high", "critical"] },
                { "name": "browser", "type": "string" },
                { "name": "reproducible", "type": "boolean" }
            ]
        },
        {
            "type_id": "b2c3d4e5f6",
            "name": "task",
            "display_name": "Task",
            "description": "Unit of work to be completed",
            "icon": "check-square",
            "color": "#3b82f6",
            "statuses": ["backlog", "todo", "in-progress", "review", "done"],
            "default_status": "backlog",
            "properties": [
                { "name": "estimate_hours", "type": "number" },
                { "name": "actual_hours", "type": "number" }
            ]
        }
    ]
}
```

### link-types.json

**File:** `.issues/config/link-types.json`

```json
{
    "link_types": [
        {
            "link_type_id": "l1m2n3o4p5",
            "verb": "blocks",
            "inverse_verb": "blocked-by",
            "description": "Source prevents progress on target",
            "source_types": ["bug", "task", "story"],
            "target_types": ["task", "story", "feature"]
        },
        {
            "link_type_id": "q6r7s8t9u0",
            "verb": "has-task",
            "inverse_verb": "task-of",
            "description": "Source contains target as sub-work",
            "source_types": ["feature", "epic", "story"],
            "target_types": ["task"]
        },
        {
            "link_type_id": "v1w2x3y4z5",
            "verb": "assigned-to",
            "inverse_verb": "assignee-of",
            "description": "Work assigned to person/agent",
            "source_types": ["bug", "task", "story", "feature"],
            "target_types": ["person"]
        }
    ]
}
```

---

## Summary

This architecture transforms our simple issue tracker into a **graph-based coordination system** that:

1. **Scales** — From simple to-do lists to complex project graphs
2. **Integrates** — Works natively with AI agents
3. **Persists** — Uses Git for durability and version control
4. **Visualises** — Structured data enables graph rendering
5. **Edits** — Human-readable files for direct repository editing

The system is designed to grow: start with basic bug/task tracking, evolve into full project coordination with dependencies, ownership, and automated workflows.

---

*Document prepared for implementation review. Architecture subject to refinement based on refactoring outcomes.*
