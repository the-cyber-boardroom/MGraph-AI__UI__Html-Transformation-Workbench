# Backend Brief: Memory-FS Integration for Graph-Based Issue Tracking

**Version:** 0.2.4  
**Status:** Architecture Design  
**Companion to:** v0.3.0 Graph-Based Issue Tracking System  
**Memory-FS Version:** v0.36.2+

---

## Executive Summary

This document describes how Memory-FS integrates with the graph-based issue tracking system defined in v0.3.0. Memory-FS provides a **storage abstraction layer** that decouples our code from the underlying storage medium — whether files are stored on local disk, in-memory, in a ZIP archive, SQLite database, or cloud storage, our code remains unchanged.

The key insight is that Memory-FS solves the WHERE problem (storage backend) while we solve the WHAT problem (graph nodes and relationships). This separation enables:

- **Testing without I/O**: Unit tests run entirely in-memory with zero file system access
- **Backend flexibility**: Deploy to local disk for Git workflows, S3 for cloud, or SQLite for embedded use
- **Single codebase**: No storage-specific code paths in our business logic

---

## Part 1: Architecture Overview

### Layer Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    FastAPI Routes                            │
│            (Routes__Nodes, Routes__Links, etc.)              │
├─────────────────────────────────────────────────────────────┤
│                    Service Layer                             │
│         (Node__Service, Link__Service, Type__Service)        │
├─────────────────────────────────────────────────────────────┤
│                    Repository Layer                          │
│                   (Graph__Repository)                        │
│         - Node CRUD, Link CRUD, Index management             │
│         - Attachment handling with compression               │
│         - Schema serialization/deserialization               │
├─────────────────────────────────────────────────────────────┤
│                    Memory-FS Layer                           │
│              (Memory_FS + Custom Path Handler)               │
│         - File operations abstraction                        │
│         - Path generation for graph structure                │
│         - Single-file JSON mode                              │
├─────────────────────────────────────────────────────────────┤
│                    Storage Backend                           │
│    ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│    │  Memory  │  │  Local   │  │  SQLite  │  │    S3    │  │
│    │ (tests)  │  │  Disk    │  │          │  │ (cloud)  │  │
│    └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### What Each Layer Does

| Layer | Responsibility | Knows About Storage? |
|-------|---------------|---------------------|
| **Routes** | HTTP endpoints, request validation | No |
| **Services** | Business logic, workflows | No |
| **Repository** | Node/edge/index management, compression | No — uses Memory-FS interface |
| **Memory-FS** | File abstraction, path generation | No — uses Storage_FS interface |
| **Storage Backend** | Actual byte persistence | Yes — specific to medium |

### Key Design Principle

**Our code never imports storage-specific classes.** The Repository only interacts with Memory-FS. Memory-FS only interacts with Storage_FS. This means:

```python
# ❌ WRONG - Storage-coupled code
from osbot_utils.utils.Files import file_create, file_contents
file_create('/path/to/Bug-27/node.json', json_data)

# ✅ CORRECT - Storage-agnostic code  
self.memory_fs.file('Bug-27/node').save(json_data)
```

---

## Part 2: Memory-FS Configuration

### Single-File JSON Mode

We use Memory-FS in **single-file mode** — each logical file is stored as exactly one physical file. This differs from Memory-FS's default 3-file mode (content + config + metadata) and is critical for Git browsability.

```python
from memory_fs                                      import Memory_FS
from memory_fs.file_types.Memory_FS__File__Type     import Memory_FS__File__Type__Json__Single

# Configure for single-file JSON
memory_fs = Memory_FS()
memory_fs.set_file_type(Memory_FS__File__Type__Json__Single)
```

**Result on disk:**
```
# Single-file mode (what we want)
.issues/data/bug/Bug-27/node.json     # Just the content

# 3-file mode (what we avoid)
.issues/data/bug/Bug-27/node.json         # Content
.issues/data/bug/Bug-27/node.config.json  # Config
.issues/data/bug/Bug-27/node.meta.json    # Metadata
```

### Custom Path Handler

We create a custom path handler that generates our graph node directory structure:

```python
from memory_fs.path_handlers.Path__Handler          import Path__Handler
from osbot_utils.type_safe.Type_Safe                import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_Str import Safe_Str


class Path__Handler__Graph_Node(Path__Handler):
    """
    Generates paths for graph nodes in the format:
        data/{node_type}/{Label}/node.json
        data/{node_type}/{Label}/attachments/{filename}
        config/node-types.json
        config/link-types.json
    """
    
    base_path : Safe_Str = Safe_Str('.issues')                   # Root directory
    
    def path_for_node(self                        ,              # Generate node file path
                      node_type : Safe_Str        ,
                      label     : Safe_Str
                 ) -> Safe_Str:
        return Safe_Str(f"{self.base_path}/data/{node_type}/{label}/node.json")
    
    def path_for_attachment(self                        ,        # Generate attachment path
                            node_type : Safe_Str        ,
                            label     : Safe_Str        ,
                            filename  : Safe_Str
                       ) -> Safe_Str:
        return Safe_Str(f"{self.base_path}/data/{node_type}/{label}/attachments/{filename}")
    
    def path_for_type_index(self                        ,        # Generate type index path
                            node_type : Safe_Str
                       ) -> Safe_Str:
        return Safe_Str(f"{self.base_path}/data/{node_type}/_index.json")
    
    def path_for_config(self                        ,            # Generate config file path
                        config_name : Safe_Str
                   ) -> Safe_Str:
        return Safe_Str(f"{self.base_path}/config/{config_name}.json")
    
    def path_for_global_index(self) -> Safe_Str:                 # Global index path
        return Safe_Str(f"{self.base_path}/_index.json")
```

### Storage Backend Selection

The repository accepts a pre-configured Memory-FS instance, allowing the application to choose the backend:

```python
class Graph__Repository(Type_Safe):
    memory_fs : Memory_FS                                        # Injected dependency
    
    # Repository never knows what storage backend is used
```

**Configuration at application startup:**

```python
# For unit tests — blazing fast, no I/O
def create_test_repository():
    memory_fs = Memory_FS()
    memory_fs.set_storage__memory()                              # In-memory storage
    memory_fs.set_file_type(Memory_FS__File__Type__Json__Single)
    return Graph__Repository(memory_fs=memory_fs)

# For development — Git-tracked files
def create_dev_repository():
    memory_fs = Memory_FS()
    memory_fs.set_storage__local_disk(root_path='.issues')       # Local file system
    memory_fs.set_file_type(Memory_FS__File__Type__Json__Single)
    return Graph__Repository(memory_fs=memory_fs)

# For cloud deployment — S3-backed
def create_prod_repository():
    memory_fs = Memory_FS()
    memory_fs.set_storage__s3(bucket='my-issues-bucket')         # S3 storage
    memory_fs.set_file_type(Memory_FS__File__Type__Json__Single)
    return Graph__Repository(memory_fs=memory_fs)
```

---

## Part 3: Repository Implementation

### Graph__Repository Class

The repository uses Memory-FS for all storage operations:

```python
from typing                                                     import Optional, List
from memory_fs                                                  import Memory_FS
from osbot_utils.type_safe.Type_Safe                            import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_Str             import Safe_Str
from osbot_utils.utils.Json                                     import json_dumps, json_loads


class Graph__Repository(Type_Safe):
    memory_fs    : Memory_FS                                     # Storage abstraction
    path_handler : Path__Handler__Graph_Node                     # Path generation

    # ═══════════════════════════════════════════════════════════════════════════════
    # Node Operations
    # ═══════════════════════════════════════════════════════════════════════════════

    def node_save(self, node: Schema__Node) -> bool:             # Save node to storage
        path = self.path_handler.path_for_node(node_type = node.node_type,
                                               label     = node.label    )
        data = self.serialize_node(node)
        return self.memory_fs.file__save(path, json_dumps(data).encode())

    def node_load(self                              ,            # Load node from storage
                  node_type : Safe_Str              ,
                  label     : Safe_Str
             ) -> Optional[Schema__Node]:
        path = self.path_handler.path_for_node(node_type = node_type,
                                               label     = label    )
        if self.memory_fs.file__exists(path) is False:
            return None
        
        data = json_loads(self.memory_fs.file__str(path))
        return self.parse_node(data)

    def node_delete(self                              ,          # Delete node from storage
                    node_type : Safe_Str              ,
                    label     : Safe_Str
               ) -> bool:
        path = self.path_handler.path_for_node(node_type = node_type,
                                               label     = label    )
        return self.memory_fs.file__delete(path)

    def node_exists(self                              ,          # Check if node exists
                    node_type : Safe_Str              ,
                    label     : Safe_Str
               ) -> bool:
        path = self.path_handler.path_for_node(node_type = node_type,
                                               label     = label    )
        return self.memory_fs.file__exists(path)

    # ═══════════════════════════════════════════════════════════════════════════════
    # Index Operations
    # ═══════════════════════════════════════════════════════════════════════════════

    def type_index_load(self, node_type: Safe_Str                # Load type index
                   ) -> Schema__Type__Index:
        path = self.path_handler.path_for_type_index(node_type)
        if self.memory_fs.file__exists(path) is False:
            return Schema__Type__Index(node_type = node_type)    # Return empty index
        
        data = json_loads(self.memory_fs.file__str(path))
        return self.parse_type_index(data)

    def type_index_save(self                              ,      # Save type index
                        node_type : Safe_Str              ,
                        index     : Schema__Type__Index
                   ) -> bool:
        path = self.path_handler.path_for_type_index(node_type)
        data = self.serialize_type_index(index)
        return self.memory_fs.file__save(path, json_dumps(data).encode())

    # ═══════════════════════════════════════════════════════════════════════════════
    # Attachment Operations
    # ═══════════════════════════════════════════════════════════════════════════════

    def attachment_save(self                              ,      # Save attachment (with compression)
                        node_type : Safe_Str              ,
                        label     : Safe_Str              ,
                        filename  : Safe_Str              ,
                        data      : bytes
                   ) -> bool:
        compressed = self.compress_if_image(filename, data)      # Our compression logic
        path = self.path_handler.path_for_attachment(node_type = node_type,
                                                     label     = label    ,
                                                     filename  = filename )
        return self.memory_fs.file__save(path, compressed)

    def attachment_load(self                              ,      # Load attachment
                        node_type : Safe_Str              ,
                        label     : Safe_Str              ,
                        filename  : Safe_Str
                   ) -> Optional[bytes]:
        path = self.path_handler.path_for_attachment(node_type = node_type,
                                                     label     = label    ,
                                                     filename  = filename )
        if self.memory_fs.file__exists(path) is False:
            return None
        return self.memory_fs.file__bytes(path)

    # ═══════════════════════════════════════════════════════════════════════════════
    # Config Operations
    # ═══════════════════════════════════════════════════════════════════════════════

    def config_load(self, config_name: Safe_Str) -> Optional[dict]:
        path = self.path_handler.path_for_config(config_name)
        if self.memory_fs.file__exists(path) is False:
            return None
        return json_loads(self.memory_fs.file__str(path))

    def config_save(self                              ,          # Save config file
                    config_name : Safe_Str            ,
                    data        : dict
               ) -> bool:
        path = self.path_handler.path_for_config(config_name)
        return self.memory_fs.file__save(path, json_dumps(data, indent=2).encode())

    # ═══════════════════════════════════════════════════════════════════════════════
    # Serialization (uses our schemas, not Memory-FS metadata)
    # ═══════════════════════════════════════════════════════════════════════════════

    def serialize_node(self, node: Schema__Node) -> dict:        # Convert node to dict
        # ... implementation from v0.3.0 brief
        pass

    def parse_node(self, data: dict) -> Schema__Node:            # Convert dict to node
        # ... implementation from v0.3.0 brief
        pass
```

---

## Part 4: Testing Patterns

### In-Memory Testing

Tests use Memory-FS in memory mode for instant execution:

```python
from unittest                                                   import TestCase
from memory_fs                                                  import Memory_FS
from memory_fs.storages.Storage_FS__Memory                      import Storage_FS__Memory


class test_Graph__Repository(TestCase):

    @classmethod
    def setUpClass(cls):                                         # Shared setup
        cls.memory_fs = Memory_FS()
        cls.memory_fs.set_storage__memory()                      # In-memory — no disk I/O
        cls.repository = Graph__Repository(memory_fs=cls.memory_fs)

    def setUp(self):                                             # Reset before each test
        self.memory_fs.storage_fs.clear()                        # Wipe all "files"

    def test_node_save_and_load(self):                           # Test node persistence
        node = Schema__Node(node_id    = Safe_Id('a1b2c3d4e5'),
                            node_type  = Safe_Str('bug')        ,
                            node_index = Safe_UInt(27)          ,
                            label      = Safe_Str('Bug-27')     ,
                            title      = Safe_Str('Test bug')   )

        self.repository.node_save(node)

        loaded = self.repository.node_load(node_type = Safe_Str('bug')   ,
                                           label     = Safe_Str('Bug-27'))

        assert loaded is not None
        assert str(loaded.node_id) == 'a1b2c3d4e5'
        assert str(loaded.title)   == 'Test bug'

    def test_node_delete(self):                                  # Test node deletion
        node = Schema__Node(node_type = Safe_Str('task')    ,
                            label     = Safe_Str('Task-1')  ,
                            title     = Safe_Str('Delete me'))

        self.repository.node_save(node)
        assert self.repository.node_exists(Safe_Str('task'), Safe_Str('Task-1')) is True

        self.repository.node_delete(Safe_Str('task'), Safe_Str('Task-1'))
        assert self.repository.node_exists(Safe_Str('task'), Safe_Str('Task-1')) is False
```

### Test Isolation

Each test starts with a clean slate:

```python
def setUp(self):
    self.memory_fs.storage_fs.clear()   # Instant — just clears a dictionary
```

Compare to file-based cleanup:

```python
# ❌ SLOW - File system operations
def setUp(self):
    folder_delete_all('/tmp/test-issues')
    folder_create('/tmp/test-issues')
```

### Integration Testing

For testing Git integration, use Local Disk backend in a temp directory:

```python
class test_Git_Integration(TestCase):

    @classmethod
    def setUpClass(cls):
        cls.temp_dir = tempfile.mkdtemp()
        cls.memory_fs = Memory_FS()
        cls.memory_fs.set_storage__local_disk(root_path=cls.temp_dir)
        cls.repository = Graph__Repository(memory_fs=cls.memory_fs)

    @classmethod
    def tearDownClass(cls):
        shutil.rmtree(cls.temp_dir)

    def test_files_are_git_browsable(self):
        node = Schema__Node(node_type = Safe_Str('bug')    ,
                            label     = Safe_Str('Bug-1')  ,
                            title     = Safe_Str('Test')   )

        self.repository.node_save(node)

        # Verify actual file exists on disk
        expected_path = f"{self.temp_dir}/.issues/data/bug/Bug-1/node.json"
        assert os.path.exists(expected_path)

        # Verify JSON is human-readable
        with open(expected_path) as f:
            content = json.load(f)
        assert content['title'] == 'Test'
```

---

## Part 5: Storage Backend Reference

### Available Backends

| Backend | Class | Use Case | Persistence |
|---------|-------|----------|-------------|
| **Memory** | `Storage_FS__Memory` | Unit tests, caching | None (process lifetime) |
| **Local Disk** | `Storage_FS__Local_Disk` | Development, Git workflows | Files on disk |
| **SQLite** | `Storage_FS__Sqlite` | Embedded applications | Single .db file |
| **S3** | `Storage_FS__S3` | Cloud deployment | AWS S3 bucket |
| **ZIP** | `Storage_FS__Zip` | Archives, export | Single .zip file |

### Backend Configuration Examples

```python
# Memory (tests)
memory_fs.set_storage__memory()

# Local Disk (development)
memory_fs.set_storage__local_disk(root_path='/path/to/repo')

# SQLite (embedded)
memory_fs.set_storage__sqlite(db_path='/path/to/issues.db')

# S3 (production)
memory_fs.set_storage__s3(bucket='my-bucket', prefix='issues/')

# ZIP (export)
memory_fs.set_storage__zip(zip_path='/path/to/export.zip')
```

### Performance Characteristics

| Operation | Memory | Local Disk | SQLite | S3 |
|-----------|--------|------------|--------|-----|
| Read | ~10μs | ~1ms | ~1ms | ~50-200ms |
| Write | ~10μs | ~5ms | ~5ms | ~100-500ms |
| Delete | ~10μs | ~1ms | ~1ms | ~50-100ms |
| List | O(n) | O(n) | O(n) | O(n) + pagination |

---

## Part 6: Directory Structure Mapping

### Memory-FS Paths → Physical Paths

When using Local Disk backend with `root_path='.issues'`:

| Memory-FS Path | Physical Path |
|----------------|---------------|
| `data/bug/Bug-27/node.json` | `.issues/data/bug/Bug-27/node.json` |
| `data/bug/Bug-27/attachments/screenshot.png` | `.issues/data/bug/Bug-27/attachments/screenshot.png` |
| `data/task/_index.json` | `.issues/data/task/_index.json` |
| `config/node-types.json` | `.issues/config/node-types.json` |
| `config/link-types.json` | `.issues/config/link-types.json` |
| `_index.json` | `.issues/_index.json` |

### Resulting Git Repository Structure

```
your-project/
├── .issues/
│   ├── _index.json
│   ├── config/
│   │   ├── node-types.json
│   │   └── link-types.json
│   └── data/
│       ├── bug/
│       │   ├── _index.json
│       │   ├── Bug-1/
│       │   │   ├── node.json
│       │   │   └── attachments/
│       │   │       └── screenshot.png
│       │   └── Bug-2/
│       │       └── node.json
│       ├── task/
│       │   ├── _index.json
│       │   └── Task-1/
│       │       └── node.json
│       └── person/
│           ├── _index.json
│           └── Person-alice/
│               └── node.json
├── src/
│   └── ...
└── README.md
```

---

## Part 7: Migration from v0.2.2

### Current Code (File-Based)

```python
# v0.2.2 - Direct file operations
from osbot_utils.utils.Files import file_create, file_contents, path_combine

class Issue__Repository:
    def save_issue(self, issue):
        path = path_combine(self.base_path, f'{issue.id}.json')
        file_create(path, json_dumps(issue))
```

### New Code (Memory-FS)

```python
# v0.3.0 - Memory-FS abstraction
class Graph__Repository:
    memory_fs    : Memory_FS
    path_handler : Path__Handler__Graph_Node

    def node_save(self, node):
        path = self.path_handler.path_for_node(node.node_type, node.label)
        self.memory_fs.file__save(path, json_dumps(node).encode())
```

### Migration Steps

1. **Replace `osbot_utils.utils.Files` imports** with Memory-FS operations
2. **Create `Path__Handler__Graph_Node`** for our path structure
3. **Inject `Memory_FS` instance** into Repository
4. **Update tests** to use in-memory backend
5. **Configure application** to select backend at startup

---

## Part 8: Implementation Checklist

### Phase 1: Memory-FS Integration

- [ ] Create `Path__Handler__Graph_Node` class
- [ ] Create `Graph__Repository` class with Memory-FS
- [ ] Configure single-file JSON mode
- [ ] Add storage backend factory methods
- [ ] Write unit tests with memory backend

### Phase 2: Service Layer

- [ ] Update `Node__Service` to use `Graph__Repository`
- [ ] Update `Link__Service` to use `Graph__Repository`
- [ ] Update `Type__Service` for config files
- [ ] Update `Attachment__Service` with compression

### Phase 3: Testing

- [ ] Convert all tests to in-memory backend
- [ ] Add integration tests with local disk backend
- [ ] Verify Git browsability of generated files
- [ ] Performance benchmarks for each backend

### Phase 4: Deployment Options

- [ ] Document local disk setup for Git workflows
- [ ] Document S3 setup for cloud deployment
- [ ] Document SQLite setup for embedded use
- [ ] Create backend selection configuration

---

## Summary

Memory-FS provides the storage abstraction layer for our graph-based issue tracking system:

| Concern | Handled By |
|---------|------------|
| **Node/Edge schemas** | Our code (v0.3.0 brief) |
| **Path structure** | `Path__Handler__Graph_Node` |
| **File operations** | Memory-FS |
| **Storage medium** | Storage_FS backends |
| **Metadata tracking** | Our schemas (not Memory-FS metadata) |
| **Compression** | Our code (attachment layer) |
| **Index management** | Our code |

This separation ensures:

1. **Tests run instantly** — Memory backend, no I/O
2. **Code is backend-agnostic** — Repository never imports storage classes
3. **Git workflows work** — Local disk backend produces browsable files
4. **Cloud is possible** — S3 backend for production if needed
5. **Type safety maintained** — Memory-FS uses Type_Safe throughout

The result is a clean architecture where our domain logic (nodes, edges, relationships) is completely independent of storage decisions.

---

*Document prepared for implementation. To be used alongside v0.3.0 Graph-Based Issue Tracking System brief.*
