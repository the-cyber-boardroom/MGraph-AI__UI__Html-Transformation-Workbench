# LLM Brief: Graph Issue Tracking - Phases 2-5

**Version**: v0.2.14
**For:** Implementation LLM  
**Prerequisite:** Phase 1 Complete (Core CRUD)  
**Date:** January 31, 2026

---

## Context: What's Already Built

Phase 1 delivered a complete graph-based issue tracking foundation:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          PHASE 1 COMPLETE                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Schemas (23 files):                                                        │
│  ├── Schema__Node, Schema__Node__Link, Schema__Node__Type                   │
│  ├── Schema__Link__Type, Schema__Property__Definition                       │
│  ├── Schema__Type__Index, Schema__Global__Index, Schema__Attachment         │
│  └── Request/Response schemas for all CRUD operations                       │
│                                                                             │
│  Services (6 files):                                                        │
│  ├── Path__Handler__Graph_Node    (path generation)                         │
│  ├── Graph__Repository            (data access via Memory-FS)               │
│  ├── Graph__Repository__Factory   (backend selection)                       │
│  ├── Node__Service                (node CRUD + business logic)              │
│  ├── Link__Service                (bidirectional link management)           │
│  └── Type__Service                (type definitions)                        │
│                                                                             │
│  Routes (3 files):                                                          │
│  ├── Routes__Nodes     GET/POST/PATCH/DELETE /api/nodes                     │
│  ├── Routes__Links     GET/POST/DELETE /api/nodes/{label}/links             │
│  └── Routes__Types     GET /api/types, /api/link-types                      │
│                                                                             │
│  Storage: Memory-FS abstraction with 4 backends                             │
│  ├── MEMORY      (tests)                                                    │
│  ├── LOCAL_DISK  (development, Git-tracked)                                 │
│  ├── SQLITE      (embedded production)                                      │
│  └── ZIP         (export/archive)                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Current Limitations:**
- Deleting a node does NOT cascade delete its links on other nodes
- No circular reference detection for dependency chains
- No path-finding between nodes
- No file upload endpoint (only backend storage exists)
- No image compression pipeline
- No activity/history logging
- No agent-specific workflows

---

## Phase 2: Advanced Relationships

### Overview

Enhance the link system with cascade operations, cycle detection, and graph queries.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PHASE 2: RELATIONSHIPS                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  2.1  Cascade Delete Links                                                  │
│  2.2  Circular Reference Detection                                          │
│  2.3  Relationship Queries                                                  │
│  2.4  Bulk Link Operations                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 2.1 Cascade Delete Links

**Problem:** When a node is deleted, orphan links remain on other nodes.

```
CURRENT BEHAVIOR (broken):
─────────────────────────

    Before delete:
    ┌─────────┐  blocks   ┌─────────┐
    │  Bug-1  │──────────▶│ Task-5  │
    └─────────┘           └─────────┘
                          links: [{verb: "blocked-by", target: "Bug-1"}]

    After DELETE /api/nodes/Bug-1:
    ┌─────────┐
    │ (gone)  │           ┌─────────┐
    └─────────┘           │ Task-5  │
                          └─────────┘
                          links: [{verb: "blocked-by", target: "Bug-1"}]  ← ORPHAN!


REQUIRED BEHAVIOR:
──────────────────

    After DELETE /api/nodes/Bug-1:
                          ┌─────────┐
                          │ Task-5  │
                          └─────────┘
                          links: []  ← Cleaned up!
```

**Implementation:**

```python
# In Node__Service.delete_node()

def delete_node(self, node_type: Safe_Str__Node_Type, label: Safe_Str__Node_Label):
    node = self.get_node(node_type, label)
    if not node:
        return Schema__Node__Delete__Response(success=False, message="Node not found")
    
    # NEW: Cascade delete all links pointing TO this node
    for link in node.links:
        target_type, target_label = self.link_service.parse_label(link.target_label)
        target_node = self.get_node(target_type, target_label)
        if target_node:
            # Remove any link from target that points back to us
            target_node.links = [
                l for l in target_node.links 
                if str(l.target_label) != str(label)
            ]
            self.repository.node_save(target_node)
    
    # Then delete the node itself
    self.repository.node_delete(node_type, label)
    self._update_type_index_on_delete(node_type)
    
    return Schema__Node__Delete__Response(success=True, deleted=True, label=label)
```

**Tests Required:**

```python
def test__delete_node__cascades_links(self):
    # Create Bug-1 blocks Task-5
    # Delete Bug-1
    # Assert Task-5.links is empty

def test__delete_node__cascades_multiple_links(self):
    # Create Bug-1 blocks Task-5, Task-6, Task-7
    # Delete Bug-1
    # Assert all three tasks have no links

def test__delete_node__cascades_bidirectional(self):
    # Create Bug-1 blocks Task-5
    # Create Bug-1 assigned-to Person-1
    # Delete Bug-1
    # Assert Task-5 and Person-1 both have no links
```

---

### 2.2 Circular Reference Detection

**Problem:** `depends-on` chains can form cycles, making work uncompletable.

```
DANGEROUS CYCLE:
────────────────

    ┌─────────┐ depends-on  ┌─────────┐ depends-on  ┌─────────┐
    │ Task-1  │────────────▶│ Task-2  │────────────▶│ Task-3  │
    └─────────┘             └─────────┘             └────┬────┘
         ▲                                               │
         │                   depends-on                  │
         └───────────────────────────────────────────────┘

    Task-1 depends on Task-2 depends on Task-3 depends on Task-1
    → DEADLOCK: Nothing can be completed!
```

**Implementation:**

```python
# New file: graph_services/Cycle__Detector.py

class Cycle__Detector(Type_Safe):
    repository : Graph__Repository
    
    def would_create_cycle(self                                    ,
                           source_label : Safe_Str__Node_Label     ,
                           target_label : Safe_Str__Node_Label     ,
                           verb         : Safe_Str__Link_Verb      ) -> bool:
        """Check if adding this link would create a dependency cycle."""
        
        # Only check cycle-prone verbs
        cyclic_verbs = {'depends-on', 'blocks', 'requires'}
        if str(verb) not in cyclic_verbs:
            return False
        
        # DFS: Can we reach source from target following same verb?
        visited = set()
        return self._can_reach(target_label, source_label, verb, visited)
    
    def _can_reach(self                                            ,
                   current : Safe_Str__Node_Label                  ,
                   target  : Safe_Str__Node_Label                  ,
                   verb    : Safe_Str__Link_Verb                   ,
                   visited : set                                   ) -> bool:
        if str(current) == str(target):
            return True
        if str(current) in visited:
            return False
        
        visited.add(str(current))
        
        node_type, _ = self._parse_label(current)
        node = self.repository.node_load(node_type, current)
        if not node:
            return False
        
        for link in node.links:
            if str(link.verb) == str(verb):
                if self._can_reach(link.target_label, target, verb, visited):
                    return True
        
        return False
    
    def find_cycle(self                                            ,
                   start_label : Safe_Str__Node_Label              ,
                   verb        : Safe_Str__Link_Verb               ) -> List[Safe_Str__Node_Label]:
        """Return the cycle path if one exists, empty list otherwise."""
        path = []
        visited = set()
        if self._find_cycle_path(start_label, verb, visited, path):
            return path
        return []
```

**Update Link__Service:**

```python
def create_link(self, source_type, source_label, request):
    # ... existing validation ...
    
    # NEW: Check for cycles
    cycle_detector = Cycle__Detector(repository=self.repository)
    if cycle_detector.would_create_cycle(source_label, request.target_label, request.verb):
        return Schema__Link__Create__Response(
            success=False,
            message=f"Cannot create link: would form circular dependency"
        )
    
    # ... proceed with link creation ...
```

**New API Endpoint:**

```
GET /api/nodes/{label}/cycles?verb=depends-on

Response:
{
  "has_cycle": true,
  "cycle_path": ["Task-1", "Task-2", "Task-3", "Task-1"]
}
```

**Tests Required:**

```python
def test__would_create_cycle__true(self):
    # Task-1 depends-on Task-2 depends-on Task-3
    # Check: would Task-3 depends-on Task-1 create cycle?
    # Assert: True

def test__would_create_cycle__false(self):
    # Task-1 depends-on Task-2
    # Check: would Task-3 depends-on Task-1 create cycle?
    # Assert: False (Task-3 not in chain)

def test__create_link__rejects_cycle(self):
    # Create chain: Task-1 → Task-2 → Task-3
    # Try to create Task-3 → Task-1
    # Assert: response.success is False
    # Assert: "circular" in response.message

def test__find_cycle__returns_path(self):
    # Create cycle
    # Assert find_cycle returns correct path
```

---

### 2.3 Relationship Queries

**New Endpoints:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        NEW RELATIONSHIP ENDPOINTS                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  GET /api/nodes/{label}/blocked-by                                          │
│      → All nodes that block this node                                       │
│                                                                             │
│  GET /api/nodes/{label}/blocking                                            │
│      → All nodes this node blocks                                           │
│                                                                             │
│  GET /api/nodes/{label}/dependencies                                        │
│      → Full dependency tree (recursive)                                     │
│                                                                             │
│  GET /api/nodes/{label}/dependents                                          │
│      → All nodes depending on this (recursive)                              │
│                                                                             │
│  GET /api/nodes/{label}/assigned                                            │
│      → All work assigned to this person                                     │
│                                                                             │
│  GET /api/nodes/{label}/path/{target_label}                                 │
│      → Shortest path between two nodes                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Implementation - Dependency Tree:**

```python
# In Link__Service

def get_dependency_tree(self                                       ,
                        label : Safe_Str__Node_Label               ,
                        depth : int = 10                           ) -> Dict:
    """Get full dependency tree for a node."""
    visited = set()
    return self._build_tree(label, 'depends-on', visited, depth)

def _build_tree(self, label, verb, visited, remaining_depth):
    if str(label) in visited or remaining_depth <= 0:
        return None
    
    visited.add(str(label))
    node_type, _ = self.parse_label(label)
    node = self.repository.node_load(node_type, label)
    
    if not node:
        return None
    
    children = []
    for link in node.links:
        if str(link.verb) == verb:
            child_tree = self._build_tree(
                link.target_label, verb, visited, remaining_depth - 1
            )
            if child_tree:
                children.append(child_tree)
    
    return {
        'label': str(label),
        'title': str(node.title),
        'status': str(node.status),
        'dependencies': children
    }
```

**Response Schema:**

```python
class Schema__Dependency__Tree(Type_Safe):
    label        : Safe_Str__Node_Label
    title        : Safe_Str__Text
    status       : Safe_Str__Status
    dependencies : List['Schema__Dependency__Tree']
```

**Example Response:**

```json
GET /api/nodes/Feature-1/dependencies

{
  "label": "Feature-1",
  "title": "User Authentication",
  "status": "in-progress",
  "dependencies": [
    {
      "label": "Task-1",
      "title": "Design login form",
      "status": "done",
      "dependencies": []
    },
    {
      "label": "Task-2",
      "title": "Implement OAuth",
      "status": "in-progress",
      "dependencies": [
        {
          "label": "Task-5",
          "title": "Set up OAuth provider",
          "status": "todo",
          "dependencies": []
        }
      ]
    }
  ]
}
```

---

### 2.4 Bulk Link Operations

**New Endpoints:**

```
POST /api/nodes/{label}/links/bulk
Content-Type: application/json

{
  "links": [
    {"verb": "blocks", "target_label": "Task-1"},
    {"verb": "blocks", "target_label": "Task-2"},
    {"verb": "assigned-to", "target_label": "Person-1"}
  ]
}

Response:
{
  "success": true,
  "created": 3,
  "failed": 0,
  "errors": []
}
```

```
DELETE /api/nodes/{label}/links/bulk
Content-Type: application/json

{
  "target_labels": ["Task-1", "Task-2", "Task-3"]
}

Response:
{
  "success": true,
  "deleted": 3,
  "failed": 0,
  "errors": []
}
```

---

## Phase 3: Attachments

### Overview

Complete the attachment system with upload endpoints and image processing.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          PHASE 3: ATTACHMENTS                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  3.1  File Upload Endpoint                                                  │
│  3.2  Image Compression Pipeline                                            │
│  3.3  Attachment Metadata in Node                                           │
│  3.4  Attachment CRUD Operations                                            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 3.1 File Upload Endpoint

**New Routes:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        ATTACHMENT ENDPOINTS                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  POST   /api/nodes/{label}/attachments                                      │
│         Content-Type: multipart/form-data                                   │
│         → Upload file, returns attachment metadata                          │
│                                                                             │
│  GET    /api/nodes/{label}/attachments                                      │
│         → List all attachments for node                                     │
│                                                                             │
│  GET    /api/nodes/{label}/attachments/{filename}                           │
│         → Download file                                                     │
│                                                                             │
│  DELETE /api/nodes/{label}/attachments/{filename}                           │
│         → Delete attachment                                                 │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**Implementation:**

```python
# New file: graph_routes/Routes__Attachments.py

from fastapi import UploadFile, File, HTTPException
from fastapi.responses import FileResponse

class Routes__Attachments(Type_Safe):
    service : Attachment__Service
    tag     : str                   = 'attachments'
    
    def setup_routes(self, app):
        @app.post("/api/nodes/{label}/attachments")
        async def upload_attachment(label: Safe_Str__Node_Label,
                                    file: UploadFile = File(...)):
            content = await file.read()
            response = self.service.upload(
                label    = label,
                filename = file.filename,
                content  = content,
                mime_type = file.content_type
            )
            if not response.success:
                raise HTTPException(status_code=400, detail=str(response.message))
            return response
        
        @app.get("/api/nodes/{label}/attachments")
        def list_attachments(label: Safe_Str__Node_Label):
            return self.service.list_attachments(label)
        
        @app.get("/api/nodes/{label}/attachments/{filename}")
        def download_attachment(label: Safe_Str__Node_Label, filename: str):
            data = self.service.download(label, filename)
            if not data:
                raise HTTPException(status_code=404, detail="Attachment not found")
            return FileResponse(
                path=data.path,
                filename=filename,
                media_type=data.mime_type
            )
        
        @app.delete("/api/nodes/{label}/attachments/{filename}")
        def delete_attachment(label: Safe_Str__Node_Label, filename: str):
            response = self.service.delete(label, filename)
            if not response.success:
                raise HTTPException(status_code=404, detail=str(response.message))
            return response
```

**Attachment Service:**

```python
# New file: graph_services/Attachment__Service.py

class Attachment__Service(Type_Safe):
    repository      : Graph__Repository
    node_service    : Node__Service
    max_file_size   : int = 10 * 1024 * 1024  # 10MB default
    allowed_types   : List[str] = ['image/png', 'image/jpeg', 'image/gif',
                                   'application/pdf', 'text/plain',
                                   'application/json']
    
    def upload(self                                                ,
               label     : Safe_Str__Node_Label                    ,
               filename  : str                                     ,
               content   : bytes                                   ,
               mime_type : str                                     ) -> Schema__Attachment__Upload__Response:
        
        # Validate node exists
        node_type, _ = self._parse_label(label)
        node = self.node_service.get_node(node_type, label)
        if not node:
            return Schema__Attachment__Upload__Response(
                success=False, message="Node not found"
            )
        
        # Validate file size
        if len(content) > self.max_file_size:
            return Schema__Attachment__Upload__Response(
                success=False, message=f"File exceeds {self.max_file_size} bytes"
            )
        
        # Validate mime type
        if mime_type not in self.allowed_types:
            return Schema__Attachment__Upload__Response(
                success=False, message=f"File type {mime_type} not allowed"
            )
        
        # Process image if applicable
        if mime_type.startswith('image/'):
            content, mime_type = self._process_image(content, mime_type)
        
        # Generate unique stored name
        stored_name = f"{Obj_Id()}_{filename}"
        
        # Save to repository
        self.repository.attachment_save(
            node_type = node_type,
            label     = label,
            filename  = stored_name,
            data      = content
        )
        
        # Create metadata
        attachment = Schema__Attachment(
            attachment_id = Obj_Id(),
            filename      = filename,
            stored_name   = stored_name,
            mime_type     = mime_type,
            size_bytes    = len(content),
            created_at    = Timestamp_Now()
        )
        
        # Add to node's attachment list
        if not hasattr(node, 'attachments') or node.attachments is None:
            node.attachments = []
        node.attachments.append(attachment)
        self.repository.node_save(node)
        
        return Schema__Attachment__Upload__Response(
            success    = True,
            attachment = attachment
        )
```

---

### 3.2 Image Compression Pipeline

**Requirements:**
- Max dimension: 1920px (resize if larger)
- JPEG quality: 85
- Strip EXIF metadata
- Convert PNG to JPEG if no transparency

```python
# In Attachment__Service

def _process_image(self, content: bytes, mime_type: str) -> Tuple[bytes, str]:
    """Compress and resize images."""
    from PIL import Image
    import io
    
    img = Image.open(io.BytesIO(content))
    
    # Resize if too large
    max_dim = 1920
    if img.width > max_dim or img.height > max_dim:
        ratio = min(max_dim / img.width, max_dim / img.height)
        new_size = (int(img.width * ratio), int(img.height * ratio))
        img = img.resize(new_size, Image.LANCZOS)
    
    # Convert to RGB if no alpha (for JPEG)
    output_format = 'JPEG'
    output_mime = 'image/jpeg'
    
    if img.mode == 'RGBA':
        # Check if actually uses transparency
        if img.split()[3].getextrema() == (255, 255):
            # No transparency, convert to RGB
            img = img.convert('RGB')
        else:
            # Has transparency, keep as PNG
            output_format = 'PNG'
            output_mime = 'image/png'
    elif img.mode != 'RGB':
        img = img.convert('RGB')
    
    # Save compressed
    output = io.BytesIO()
    if output_format == 'JPEG':
        img.save(output, format='JPEG', quality=85, optimize=True)
    else:
        img.save(output, format='PNG', optimize=True)
    
    return output.getvalue(), output_mime
```

---

### 3.3 Attachment Metadata in Node

**Update Schema__Node:**

```python
class Schema__Node(Type_Safe):
    # ... existing fields ...
    attachments : List[Schema__Attachment]                           # NEW
```

**Schema__Attachment (already exists, verify fields):**

```python
class Schema__Attachment(Type_Safe):
    attachment_id : Obj_Id
    filename      : str                                              # Original name
    stored_name   : str                                              # UUID_filename
    mime_type     : str
    size_bytes    : int
    compressed    : bool              = False
    created_at    : Timestamp_Now
    created_by    : Safe_Str__Node_Label = ''                        # Person who uploaded
```

---

### 3.4 Response Schemas

```python
class Schema__Attachment__Upload__Response(Type_Safe):
    success    : bool                 = False
    attachment : Schema__Attachment   = None
    message    : Safe_Str__Text       = ''

class Schema__Attachment__List__Response(Type_Safe):
    success     : bool                       = False
    attachments : List[Schema__Attachment]
    message     : Safe_Str__Text             = ''

class Schema__Attachment__Delete__Response(Type_Safe):
    success  : bool             = False
    deleted  : bool             = False
    filename : str              = ''
    message  : Safe_Str__Text   = ''
```

---

## Phase 4: Graph Operations

### Overview

Export, visualization, and graph traversal capabilities.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        PHASE 4: GRAPH OPERATIONS                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  4.1  Full Graph Export                                                     │
│  4.2  Subgraph Extraction                                                   │
│  4.3  Path Finding                                                          │
│  4.4  Visualization Data Format                                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 4.1 Full Graph Export

**Endpoint:**

```
GET /api/graph/export?format=json|graphml|dot

Response (JSON):
{
  "nodes": [
    {
      "id": "Bug-1",
      "type": "bug",
      "title": "Login fails",
      "status": "backlog",
      "properties": {...}
    },
    ...
  ],
  "edges": [
    {
      "source": "Bug-1",
      "target": "Task-5",
      "verb": "blocks"
    },
    ...
  ],
  "metadata": {
    "exported_at": "2026-01-31T12:00:00Z",
    "total_nodes": 42,
    "total_edges": 67
  }
}
```

**Implementation:**

```python
# New file: graph_services/Graph__Export__Service.py

class Graph__Export__Service(Type_Safe):
    repository   : Graph__Repository
    node_service : Node__Service
    
    def export_full(self, format: str = 'json') -> Union[Dict, str]:
        """Export entire graph."""
        nodes = []
        edges = []
        seen_edges = set()
        
        # Load all nodes
        for node_type in self._get_all_node_types():
            for node in self._load_all_of_type(node_type):
                nodes.append({
                    'id': str(node.label),
                    'type': str(node.node_type),
                    'title': str(node.title),
                    'status': str(node.status),
                    'properties': dict(node.properties)
                })
                
                # Collect edges (deduplicate bidirectional)
                for link in node.links:
                    edge_key = tuple(sorted([str(node.label), str(link.target_label)]))
                    if edge_key not in seen_edges:
                        edges.append({
                            'source': str(node.label),
                            'target': str(link.target_label),
                            'verb': str(link.verb)
                        })
                        seen_edges.add(edge_key)
        
        result = {
            'nodes': nodes,
            'edges': edges,
            'metadata': {
                'exported_at': str(Timestamp_Now()),
                'total_nodes': len(nodes),
                'total_edges': len(edges)
            }
        }
        
        if format == 'json':
            return result
        elif format == 'graphml':
            return self._to_graphml(result)
        elif format == 'dot':
            return self._to_dot(result)
        
        return result
    
    def _to_dot(self, data: Dict) -> str:
        """Convert to Graphviz DOT format."""
        lines = ['digraph IssueGraph {']
        lines.append('  rankdir=LR;')
        
        # Node definitions
        for node in data['nodes']:
            color = self._type_color(node['type'])
            lines.append(f'  "{node["id"]}" [label="{node["title"][:30]}" '
                        f'color="{color}" style=filled];')
        
        # Edges
        for edge in data['edges']:
            lines.append(f'  "{edge["source"]}" -> "{edge["target"]}" '
                        f'[label="{edge["verb"]}"];')
        
        lines.append('}')
        return '\n'.join(lines)
```

---

### 4.2 Subgraph Extraction

**Endpoint:**

```
GET /api/graph/subgraph?root={label}&depth=3&direction=both

Parameters:
- root: Starting node label
- depth: How many hops to include (default 2)
- direction: 'outgoing', 'incoming', or 'both'
```

**Implementation:**

```python
def extract_subgraph(self                                          ,
                     root_label : Safe_Str__Node_Label             ,
                     depth      : int = 2                          ,
                     direction  : str = 'both'                     ) -> Dict:
    """Extract subgraph centered on a node."""
    visited_nodes = set()
    edges = []
    
    self._traverse(root_label, depth, direction, visited_nodes, edges)
    
    nodes = []
    for label in visited_nodes:
        node_type, _ = self._parse_label(label)
        node = self.repository.node_load(node_type, Safe_Str__Node_Label(label))
        if node:
            nodes.append({
                'id': str(node.label),
                'type': str(node.node_type),
                'title': str(node.title),
                'status': str(node.status)
            })
    
    return {
        'root': str(root_label),
        'nodes': nodes,
        'edges': edges
    }

def _traverse(self, label, remaining_depth, direction, visited, edges):
    if remaining_depth <= 0 or str(label) in visited:
        return
    
    visited.add(str(label))
    node_type, _ = self._parse_label(label)
    node = self.repository.node_load(node_type, Safe_Str__Node_Label(label))
    
    if not node:
        return
    
    for link in node.links:
        is_outgoing = not str(link.verb).endswith('-by') and \
                      not str(link.verb).endswith('-of')
        
        should_follow = (direction == 'both' or
                        (direction == 'outgoing' and is_outgoing) or
                        (direction == 'incoming' and not is_outgoing))
        
        if should_follow:
            edge_key = (str(label), str(link.target_label), str(link.verb))
            if edge_key not in [(e['source'], e['target'], e['verb']) for e in edges]:
                edges.append({
                    'source': str(label),
                    'target': str(link.target_label),
                    'verb': str(link.verb)
                })
            self._traverse(link.target_label, remaining_depth - 1, 
                          direction, visited, edges)
```

---

### 4.3 Path Finding

**Endpoint:**

```
GET /api/graph/path?from={label}&to={label}&max_hops=10

Response:
{
  "found": true,
  "path": [
    {"label": "Bug-1", "via": null},
    {"label": "Task-5", "via": "blocks"},
    {"label": "Feature-1", "via": "task-of"},
    {"label": "Person-1", "via": "assigned-to"}
  ],
  "length": 3
}
```

**Implementation (BFS):**

```python
def find_path(self                                                 ,
              from_label : Safe_Str__Node_Label                    ,
              to_label   : Safe_Str__Node_Label                    ,
              max_hops   : int = 10                                ) -> Dict:
    """Find shortest path between two nodes using BFS."""
    from collections import deque
    
    if str(from_label) == str(to_label):
        return {
            'found': True,
            'path': [{'label': str(from_label), 'via': None}],
            'length': 0
        }
    
    # BFS queue: (current_label, path_so_far)
    queue = deque([(str(from_label), [{'label': str(from_label), 'via': None}])])
    visited = {str(from_label)}
    
    while queue:
        current, path = queue.popleft()
        
        if len(path) > max_hops:
            continue
        
        node_type, _ = self._parse_label(Safe_Str__Node_Label(current))
        node = self.repository.node_load(node_type, Safe_Str__Node_Label(current))
        
        if not node:
            continue
        
        for link in node.links:
            target = str(link.target_label)
            
            if target == str(to_label):
                # Found!
                final_path = path + [{'label': target, 'via': str(link.verb)}]
                return {
                    'found': True,
                    'path': final_path,
                    'length': len(final_path) - 1
                }
            
            if target not in visited:
                visited.add(target)
                new_path = path + [{'label': target, 'via': str(link.verb)}]
                queue.append((target, new_path))
    
    return {'found': False, 'path': [], 'length': -1}
```

---

### 4.4 Visualization Data Format

**Endpoint for D3.js/Cytoscape.js:**

```
GET /api/graph/viz?format=d3|cytoscape

Response (D3 format):
{
  "nodes": [
    {"id": "Bug-1", "group": "bug", "label": "Login fails", "size": 10},
    {"id": "Task-5", "group": "task", "label": "Implement OAuth", "size": 8}
  ],
  "links": [
    {"source": "Bug-1", "target": "Task-5", "value": 1, "label": "blocks"}
  ]
}

Response (Cytoscape format):
{
  "elements": {
    "nodes": [
      {"data": {"id": "Bug-1", "label": "Login fails", "type": "bug"}}
    ],
    "edges": [
      {"data": {"source": "Bug-1", "target": "Task-5", "label": "blocks"}}
    ]
  }
}
```

---

## Phase 5: Agent Integration

### Overview

Support AI agents as first-class participants in issue tracking.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        PHASE 5: AGENT INTEGRATION                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  5.1  Agent Identity Management                                             │
│  5.2  Assignment Workflows                                                  │
│  5.3  Activity Logging                                                      │
│  5.4  Agent-Specific Queries                                                │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 5.1 Agent Identity Management

**Concept:** Agents are `person` nodes with special properties.

```python
# Agent-specific properties in Schema__Node.properties

{
  "agent_type": "llm",              # "llm", "bot", "automation"
  "agent_model": "claude-3-opus",   # Model identifier
  "agent_version": "2026-01",       # Version
  "capabilities": ["code", "review", "test"],
  "rate_limit": 100,                # Max operations per hour
  "supervisor": "Person-1"          # Human supervisor label
}
```

**New Endpoint:**

```
POST /api/agents
Content-Type: application/json

{
  "name": "CodeReviewer-1",
  "agent_type": "llm",
  "agent_model": "claude-3-opus",
  "capabilities": ["code", "review"],
  "supervisor": "Person-1"
}

Response:
{
  "success": true,
  "node": {
    "label": "Person-3",
    "title": "CodeReviewer-1",
    "node_type": "person",
    "properties": {
      "agent_type": "llm",
      "agent_model": "claude-3-opus",
      ...
    }
  }
}
```

**Agent Service:**

```python
# New file: graph_services/Agent__Service.py

class Agent__Service(Type_Safe):
    node_service : Node__Service
    link_service : Link__Service
    
    def create_agent(self, request: Schema__Agent__Create__Request):
        # Create as person node with agent properties
        node_request = Schema__Node__Create__Request(
            node_type   = Safe_Str__Node_Type('person'),
            title       = request.name,
            status      = Safe_Str__Status('active'),
            properties  = {
                'agent_type'   : request.agent_type,
                'agent_model'  : request.agent_model,
                'agent_version': request.agent_version,
                'capabilities' : request.capabilities,
                'rate_limit'   : request.rate_limit,
                'is_agent'     : True
            }
        )
        
        response = self.node_service.create_node(node_request)
        
        # Link to supervisor if specified
        if request.supervisor and response.success:
            self.link_service.create_link(
                source_type  = Safe_Str__Node_Type('person'),
                source_label = response.node.label,
                request      = Schema__Link__Create__Request(
                    verb         = Safe_Str__Link_Verb('supervised-by'),
                    target_label = request.supervisor
                )
            )
        
        return response
    
    def list_agents(self):
        """List all agent persons."""
        all_persons = self.node_service.list_nodes(Safe_Str__Node_Type('person'))
        return [p for p in all_persons if p.properties.get('is_agent', False)]
    
    def get_agent_workload(self, label: Safe_Str__Node_Label):
        """Get current assignments for an agent."""
        node = self.node_service.get_node(Safe_Str__Node_Type('person'), label)
        if not node or not node.properties.get('is_agent'):
            return None
        
        assignments = [l for l in node.links if str(l.verb) == 'assignee-of']
        return {
            'agent': str(label),
            'total_assigned': len(assignments),
            'assignments': [str(a.target_label) for a in assignments]
        }
```

---

### 5.2 Assignment Workflows

**Auto-Assignment Rules:**

```python
class Schema__Assignment__Rule(Type_Safe):
    rule_id     : Obj_Id
    name        : str
    priority    : int                  = 0
    conditions  : Dict[str, Any]       # {"node_type": "bug", "tags": ["security"]}
    assign_to   : Safe_Str__Node_Label # Agent or person label
    enabled     : bool                 = True
```

**Assignment Service:**

```python
class Assignment__Service(Type_Safe):
    node_service : Node__Service
    link_service : Link__Service
    rules        : List[Schema__Assignment__Rule]
    
    def auto_assign(self, node: Schema__Node) -> Optional[Safe_Str__Node_Label]:
        """Find best assignee based on rules."""
        for rule in sorted(self.rules, key=lambda r: -r.priority):
            if not rule.enabled:
                continue
            if self._matches_conditions(node, rule.conditions):
                # Check agent availability
                if self._is_available(rule.assign_to):
                    return rule.assign_to
        return None
    
    def _matches_conditions(self, node: Schema__Node, conditions: Dict) -> bool:
        if 'node_type' in conditions:
            if str(node.node_type) != conditions['node_type']:
                return False
        if 'tags' in conditions:
            node_tags = [str(t) for t in node.tags]
            if not any(t in node_tags for t in conditions['tags']):
                return False
        if 'status' in conditions:
            if str(node.status) != conditions['status']:
                return False
        return True
    
    def _is_available(self, label: Safe_Str__Node_Label) -> bool:
        """Check if assignee is under rate limit."""
        workload = self.agent_service.get_agent_workload(label)
        if not workload:
            return True  # Human, always available
        
        node = self.node_service.get_node(Safe_Str__Node_Type('person'), label)
        rate_limit = node.properties.get('rate_limit', 100)
        
        return workload['total_assigned'] < rate_limit
```

---

### 5.3 Activity Logging

**Schema:**

```python
class Schema__Activity(Type_Safe):
    activity_id : Obj_Id
    timestamp   : Timestamp_Now
    actor       : Safe_Str__Node_Label    # Who did it
    action      : str                     # "created", "updated", "linked", etc.
    target      : Safe_Str__Node_Label    # What was affected
    details     : Dict[str, Any]          # Action-specific data
```

**Storage:**

```
.issues/
└── activity/
    └── 2026-01-31.jsonl              # Daily activity log (JSON Lines)
```

**Activity Service:**

```python
class Activity__Service(Type_Safe):
    repository : Graph__Repository
    
    def log(self                                                   ,
            actor   : Safe_Str__Node_Label                         ,
            action  : str                                          ,
            target  : Safe_Str__Node_Label                         ,
            details : Dict[str, Any] = None                        ):
        activity = Schema__Activity(
            activity_id = Obj_Id(),
            timestamp   = Timestamp_Now(),
            actor       = actor,
            action      = action,
            target      = target,
            details     = details or {}
        )
        
        # Append to daily log
        date_str = datetime.now().strftime('%Y-%m-%d')
        log_path = f".issues/activity/{date_str}.jsonl"
        
        self.repository.append_line(log_path, activity.json())
    
    def get_history(self                                           ,
                    target : Safe_Str__Node_Label                  ,
                    limit  : int = 50                              ) -> List[Schema__Activity]:
        """Get activity history for a node."""
        # Read recent log files and filter by target
        ...
    
    def get_agent_activity(self                                    ,
                           agent  : Safe_Str__Node_Label           ,
                           since  : datetime = None                ) -> List[Schema__Activity]:
        """Get all activity by an agent."""
        ...
```

**Integrate with Services:**

```python
# In Node__Service.create_node()
def create_node(self, request, actor: Safe_Str__Node_Label = None):
    response = self._do_create(request)
    
    if response.success and actor:
        self.activity_service.log(
            actor   = actor,
            action  = 'created',
            target  = response.node.label,
            details = {'title': str(response.node.title)}
        )
    
    return response
```

---

### 5.4 Agent-Specific Queries

**New Endpoints:**

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          AGENT ENDPOINTS                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  GET  /api/agents                                                           │
│       → List all agents                                                     │
│                                                                             │
│  POST /api/agents                                                           │
│       → Create new agent                                                    │
│                                                                             │
│  GET  /api/agents/{label}/workload                                          │
│       → Current assignments and capacity                                    │
│                                                                             │
│  GET  /api/agents/{label}/activity                                          │
│       → Recent activity by this agent                                       │
│                                                                             │
│  POST /api/agents/{label}/assign                                            │
│       → Manually assign work to agent                                       │
│       Body: {"target_label": "Bug-27"}                                      │
│                                                                             │
│  POST /api/agents/{label}/complete                                          │
│       → Mark assigned work as complete                                      │
│       Body: {"target_label": "Bug-27", "resolution": "fixed"}               │
│                                                                             │
│  GET  /api/activity?target={label}&actor={label}&since={datetime}           │
│       → Query activity log                                                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Summary: Files to Create

### Phase 2: Relationships
```
graph_services/
├── Cycle__Detector.py              # Circular reference detection
└── (update) Link__Service.py       # Add cycle check, bulk ops

graph_routes/
└── (update) Routes__Links.py       # Add bulk endpoints, queries

graph_schemas/
├── Schema__Dependency__Tree.py
├── Schema__Link__Bulk__Request.py
└── Schema__Link__Bulk__Response.py

tests/
├── test_Cycle__Detector.py
├── test_Link__Service__cascade.py
└── test_Link__Service__bulk.py
```

### Phase 3: Attachments
```
graph_services/
└── Attachment__Service.py

graph_routes/
└── Routes__Attachments.py

graph_schemas/
├── Schema__Attachment__Upload__Response.py
├── Schema__Attachment__List__Response.py
└── Schema__Attachment__Delete__Response.py

tests/
├── test_Attachment__Service.py
└── test_Routes__Attachments.py
```

### Phase 4: Graph Operations
```
graph_services/
└── Graph__Export__Service.py

graph_routes/
└── Routes__Graph.py

graph_schemas/
├── Schema__Graph__Export.py
├── Schema__Subgraph.py
└── Schema__Path__Result.py

tests/
├── test_Graph__Export__Service.py
└── test_Routes__Graph.py
```

### Phase 5: Agent Integration
```
graph_services/
├── Agent__Service.py
├── Assignment__Service.py
└── Activity__Service.py

graph_routes/
├── Routes__Agents.py
└── Routes__Activity.py

graph_schemas/
├── Schema__Agent__Create__Request.py
├── Schema__Assignment__Rule.py
├── Schema__Activity.py
└── Schema__Agent__Workload.py

tests/
├── test_Agent__Service.py
├── test_Assignment__Service.py
├── test_Activity__Service.py
├── test_Routes__Agents.py
└── test_Routes__Activity.py
```

---

## Implementation Order

```
Recommended sequence:
────────────────────

Phase 2.1: Cascade Delete        (required - currently broken)
    ↓
Phase 2.2: Cycle Detection       (safety feature)
    ↓
Phase 3.1-3.3: Attachments       (user-facing feature)
    ↓
Phase 2.3: Relationship Queries  (enables Phase 4)
    ↓
Phase 4.1-4.4: Graph Operations  (visualization support)
    ↓
Phase 5.1: Agent Identity        (foundation for 5.2-5.4)
    ↓
Phase 5.3: Activity Logging      (audit trail)
    ↓
Phase 5.2: Assignment Workflows  (automation)
    ↓
Phase 5.4: Agent Queries         (operational visibility)
```

---

## Testing Requirements

All tests must:
1. Use real services with in-memory backend (no mocks)
2. Follow `setUpClass` for expensive setup
3. Use `setUp` for per-test state reset
4. Follow one-to-one method-to-test mapping
5. Use inline comments, never docstrings

Minimum coverage targets:
- Phase 2: 40 new tests
- Phase 3: 25 new tests
- Phase 4: 30 new tests
- Phase 5: 50 new tests

---

## Conclusion

This brief provides complete specifications for Phases 2-5. Start with Phase 2.1 (cascade delete) as it fixes a current bug, then proceed through the phases in the recommended order. Each phase builds on previous work while remaining independently deployable.
